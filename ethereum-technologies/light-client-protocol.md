# 轻客户端协议

* [背景知识：Merkle Patricia Tree](https://github.com/ethereum/wiki/wiki/Light-client-protocol#background-patricia-merkle-trees)
  * [规则](https://github.com/ethereum/wiki/wiki/Light-client-protocol#principles)

\_\_

_有关协议规范的当前状态，请参见以下链接。_

* [https://github.com/ethereum/devp2p/blob/master/caps/les.md](https://github.com/ethereum/devp2p/blob/master/caps/les.md)
* [https://github.com/zsfelfoldi/go-ethereum/wiki/Client-Side-Flow-Control-model-for-the-LES-protocol](https://github.com/zsfelfoldi/go-ethereum/wiki/Client-Side-Flow-Control-model-for-the-LES-protocol)

轻客户端协议的目的是为了即使是在低配环境中，也既能保证以太坊某些特定部分当前状态的高安全性，如嵌入式智能设备、智能手机、浏览器扩展程序及某些台式机，也能验证交易的执行。尽管只有完整的节点才可能具有完全的安全性，但轻客户端协议允许轻节点每2分钟处理大约1KB的数据，以从网络接收其所关注的状态数据，并确保在大多数矿工都正确遵守该协议的前提下数据是正确无误的，甚至前提可能是至少存在一个诚实的完整验证节点。

### 背景知识：Merkle Patricia Tress

以太坊中的所有数据都存储在称为[Merkle Patricia tree](https://knol.ethereum.cn/ethereum-technologies/merkle-patricia-tree)的数据结构中，该树结构中的每个节点都是其子节点的哈希值。每组键值对对应唯一的根哈希，并且只需要一小组节点即可证明树中特定的键值对是与特定的根哈希相对应的。

Merkle 证明的大小复杂度与树的高度成线性比例。因为树的每个节点都有特定数量的子节点（在Merkle Patricia Tree中，最多17个），所以Merkle证明的大小复杂度与存储的数据量成对数关系。这意味着即使整个状态树只有数GB大小，如果节点从可信来源接收到状态根，那么该节点也就可以通过仅下载证明中的数KB数据来完全明确树中任何信息的有效性。

Patricia tree节点的SPV证明仅涉及一个完整树节点集，这些树节点经过处理才能访问SPV证明，更具体来说就是需要在反向哈希查找数据库中对这些树节点进行查找。在Patricia tree的简单实现中，要检索与特定键相关联的值，就要递归哈希树，即通过其哈希值不断查找数据库中的节点，直到到达最终的叶节点为止。一种生成SPV证明的简单方法就是运行上述算法，并记录所有已进行的数据库查找。SPV验证包括运行上述查找算法，但仅需要包含SPV证明中节点的自定义数据库。如果存在“找不到节点”这种错误，则该证明无效。

## 规则

在以太坊中，在默认情况下，轻客户端可被视为下载区块头并仅验证需要验证的一小部分内容的客户端，该客户端的树节点数据库不是其本地硬盘，而是分布式哈希表 \(DHT, distributed hash table\) 。对于“部分轻客户端”来说，处理所有内容就会受硬盘驱动器空间限制，因而几乎不能存储任何内容，而用DHT get request读取数据库就足以满足其自身需求。实际上，由于超过数千个区块的历史记录，除了存档节点将被用于企业、区块浏览器之外，所有“完整客户端”最终都将被转换为“部分轻客户端”。但我们同时也有意支持完全轻客户端，这些客户端甚至处理过甚少交易。正式上可以说一个完整的轻客户端的所有度量值与区块交易数量呈亚线性关系，并受其影响。在大多数情况下，以下用例适用于O（log（n）），其中一个特定机制仅适用于O（sqrt（n））。

以下是完全轻客户端的部分用例：

* 轻客户端需要在特定时间了解帐户状态如随机数、余额、代码或存储索引。轻客户端可以仅从状态树递归下载树节点，直到下载完所需节点为止。
* 轻客户端需要检查交易是否已确认。轻客户端可以仅询问网络该交易的索引和区块号，然后递归下载交易树节点以检查交易可用性。
* 多个轻客户端需要集体验证一个区块。每个轻客户端`C [i]`选择一个具有相应收据`R [i]`的交易`T [i]`的交易索引`i`并执行以下操作：
  * 使用状态根 `R [i-1].medstate`和`R [i-1] .gas_used`初始化状态（如果`i = 0`，则使用parent endstate 和 `0` `gas_used`）
  * 处理交易`T[i]`
  * 检测状态根结果是否为`R [i] .medstate`以及gas\_used是否为`R [i] .gas_used`
  * 检查生成的日志和bloom集是否匹配`R [i] .logs`和`R [i] .logbloom`
  * 检查bloom是否是区块头bloom的子集，这能检测到假负区块头bloom。然后从区块头的bloom中选取部分随机索引，其中该bloom包含一个1，再向其他节点询问在该索引包含1的交易bloom，如果没有给出响应，则拒绝该区块，这步骤能检测到假正区块头bloom）
* 轻客户端需要“监视”已记录的事件。步骤如下：
  * 轻客户端获取所有区块头，查找区块头，这些区块头要包含与该轻客户端需要的其中一个地址或主题列表匹配的bloom filter。
  * 在找到可能匹配的区块头后，轻客户端下载所有交易收据，并检测出与bloom filter匹配的交易
  * 找到潜在匹配的交易后，轻客户端检查其实际日志RLP，并查看该交易是否实际匹配

前三个轻客户端协议需要使用对数函数访问和计算数据；由于bloom ffilter只是一个两级结构，因此第四个协议需要用到〜O（sqrt（N））。如果轻客户端愿意依靠多个提供者来指向所需交易索引和错过交易了的退役提供者，则可以将此函数改进为O（log（N））。第一个协议适用于简单检查状态，第二个协议用于检查商户与消费者之间的交易是否已验证。第三种协议允许以太坊轻客户端以非常低的信任度集体验证区块。例如，在比特币中，矿工创建一个区块后，得到了超额的交易费用，而此时，轻节点无法自行检测到这种情况。在以太坊中，如果一个区块无效，那么它必须在某个索引处包含一个无效的状态转换，因此正在验证该索引的轻客户端就可以看到存在的问题。或是由于证明步骤未检出，或是由于数据不可用，该客户端就会发出警报。

如果dapp需要跟踪某些需要高效验证但不需要成为永久状态的事件，则第四种协议非常有用，如去中心化交易所或钱包的交易。用比特币的术语来说，`LOG`可以看作是纯粹的“发布证明（proof of publication）”操作码。

